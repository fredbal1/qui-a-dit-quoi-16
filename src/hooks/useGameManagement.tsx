
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from './useAuth';
import { useToast } from './use-toast';

interface GameSettings {
  mode: string;
  ambiance: string;
  miniGames: string[];
  rounds: number;
  maxPlayers: number;
}

export function useGameManagement() {
  const { user, profile } = useAuth();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  // Create a new game
  const createGameMutation = useMutation({
    mutationFn: async (settings: GameSettings) => {
      console.log('ðŸŽ® [CREATE GAME] Starting game creation with settings:', settings);
      
      if (!user || !profile) {
        console.error('âŒ [CREATE GAME] User not authenticated:', { user: !!user, profile: !!profile });
        throw new Error('User not authenticated');
      }

      console.log('âœ… [CREATE GAME] User authenticated:', { userId: user.id, pseudo: profile.pseudo });

      // Create game with required code field - will be auto-generated by trigger
      const gamePayload = {
        host_id: user.id,
        mode: settings.mode as any,
        ambiance: settings.ambiance as any,
        total_rounds: settings.rounds,
        max_players: settings.maxPlayers,
        code: '' // Will be replaced by trigger
      };

      console.log('ðŸ“¤ [CREATE GAME] Inserting game with payload:', gamePayload);

      const { data: game, error: gameError } = await supabase
        .from('games')
        .insert(gamePayload)
        .select()
        .single();

      if (gameError) {
        console.error('âŒ [CREATE GAME] Game insertion failed:', gameError);
        throw gameError;
      }

      console.log('âœ… [CREATE GAME] Game created successfully:', game);

      // Add host as first player
      const playerPayload = {
        game_id: game.id,
        user_id: user.id,
        is_host: true
      };

      console.log('ðŸ“¤ [CREATE GAME] Adding host as player with payload:', playerPayload);

      const { error: playerError } = await supabase
        .from('players')
        .insert(playerPayload);

      if (playerError) {
        console.error('âŒ [CREATE GAME] Player insertion failed:', playerError);
        throw playerError;
      }

      console.log('âœ… [CREATE GAME] Host added as player successfully');
      console.log('ðŸŽ‰ [CREATE GAME] Game creation complete! Game code:', game.code);

      return game;
    },
    onSuccess: (game) => {
      console.log('ðŸŽŠ [CREATE GAME] Success callback triggered for game:', game.code);
      toast({
        title: "Partie crÃ©Ã©e !",
        description: `Code: ${game.code}`,
      });
      queryClient.invalidateQueries({ queryKey: ['games'] });
    },
    onError: (error: any) => {
      console.error('ðŸ’¥ [CREATE GAME] Error callback triggered:', error);
      toast({
        title: "Erreur",
        description: error.message || "Impossible de crÃ©er la partie",
        variant: "destructive"
      });
    }
  });

  // Join a game by code
  const joinGameMutation = useMutation({
    mutationFn: async (gameCode: string) => {
      if (!user || !profile) throw new Error('User not authenticated');

      // Find game by code
      const { data: game, error: gameError } = await supabase
        .from('games')
        .select('*')
        .eq('code', gameCode.toUpperCase())
        .eq('status', 'waiting')
        .single();

      if (gameError) throw new Error('Code de partie invalide');

      // Check if user is already in the game
      const { data: existingPlayer } = await supabase
        .from('players')
        .select('id')
        .eq('game_id', game.id)
        .eq('user_id', user.id)
        .single();

      if (existingPlayer) {
        return game; // Already in game
      }

      // Add player to game
      const { error: playerError } = await supabase
        .from('players')
        .insert({
          game_id: game.id,
          user_id: user.id,
          is_host: false
        });

      if (playerError) {
        if (playerError.message.includes('violates')) {
          throw new Error('La partie est pleine');
        }
        throw playerError;
      }

      return game;
    },
    onSuccess: (game) => {
      toast({
        title: "Partie rejointe !",
        description: `ConnectÃ© Ã  ${game.code}`,
      });
      queryClient.invalidateQueries({ queryKey: ['games'] });
      queryClient.invalidateQueries({ queryKey: ['players'] });
    },
    onError: (error: any) => {
      toast({
        title: "Erreur",
        description: error.message || "Impossible de rejoindre la partie",
        variant: "destructive"
      });
    }
  });

  // Start a game (host only)
  const startGameMutation = useMutation({
    mutationFn: async (gameId: string) => {
      const { error } = await supabase
        .from('games')
        .update({ 
          status: 'active',
          started_at: new Date().toISOString()
        })
        .eq('id', gameId);

      if (error) throw error;
      return gameId;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['games'] });
    }
  });

  return {
    createGame: createGameMutation.mutate,
    joinGame: joinGameMutation.mutate,
    startGame: startGameMutation.mutate,
    isCreating: createGameMutation.isPending,
    isJoining: joinGameMutation.isPending,
    isStarting: startGameMutation.isPending
  };
}
